<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tizen IPTV Player</title>
    <!-- 1. Tailwind CSS for lightweight, utility-first styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 
      2. Tizen WebAPI Script
      This will only load on a real Tizen device.
    -->
    <script src="$WEBAPIS/webapis/webapis.js"></script>

    <style>
        /* 3. Custom CSS for Theming, Layouts, and Animations */
        
        /* Define color variables for theming. We start with the default dark theme. */
        body {
            /* Default Dark Theme */
            --color-bg: #111827; /* gray-900 */
            --color-bg-alt: #1F2937; /* gray-800 */
            --color-card: #374151; /* gray-700 */
            --color-text: #F9FAFB; /* gray-50 */
            --color-text-alt: #D1D5DB; /* gray-300 */
            --color-primary: #3B82F6; /* blue-500 */
            --color-primary-hover: #2563EB; /* blue-600 */
            
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden; /* Prevent browser-level scrolling */
        }

        /* Define a light theme (can be toggled with a class on the body) */
        body.light-theme {
            --color-bg: #F9FAFB; /* gray-50 */
            --color-bg-alt: #F3F4F6; /* gray-100 */
            --color-card: #FFFFFF; /* white */
            --color-text: #1F2937; /* gray-800 */
            --color-text-alt: #4B5563; /* gray-600 */
            --color-primary: #3B82F6; /* blue-500 */
            --color-primary-hover: #2563EB; /* blue-600 */
        }

        /* Page transition styles */
        .page {
            display: none; /* Hide all pages by default */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Pages should control their own scrolling */
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .page.active {
            display: block; /* Show the active page */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Custom scrollbars for content areas */
        .page-content {
            overflow-y: auto;
            height: 100%;
            /* Custom scrollbar (WebKit) */
            &::-webkit-scrollbar {
                width: 8px;
            }
            &::-webkit-scrollbar-track {
                background: var(--color-bg-alt);
                border-radius: 4px;
            }
            &::-webkit-scrollbar-thumb {
                background: var(--color-primary);
                border-radius: 4px;
            }
            &::-webkit-scrollbar-thumb:hover {
                background: var(--color-primary-hover);
            }
        }
        
        /* Focus state for all interactive items */
        .category-item:focus, .grid-item:focus, .season-item:focus, .episode-item:focus, .details-button:focus, .player-control:focus, .menu-item:focus {
            transform: scale(1.05);
            box-shadow: 0 0 0 4px var(--color-primary);
            outline: none;
            z-index: 10;
        }
        
        .category-item, .grid-item, .season-item, .episode-item, .details-button, .player-control, .menu-item {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform, box-shadow; /* Optimize for animations */
        }

        /* Loading Spinner */
        #loading-spinner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            display: none; /* Hidden by default */
        }
        .spinner {
            width: 64px;
            height: 64px;
            border: 8px solid var(--color-text-alt);
            border-top-color: var(--color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Error Message */
        #error-message {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #EF4444; /* red-500 */
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        /* Player styles */
        #web-video-player, #tizen-player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 5000;
        }
        #tizen-player-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5001; /* Above player, below controls */
            display: none;
        }
    </style>
</head>
<body class="bg-bg text-text">

    <!-- 
      Tizen Player Container 
      This is where the native Tizen player will be injected.
    -->
    <div id="tizen-player-container" style="display: none;"></div>
    
    <!-- 
      Tizen Player UI Overlay
      This empty div is required for Tizen to capture input events.
    -->
    <div id="tizen-player-overlay"></div>

    <!-- 
      Web Video Player (for testing in browser)
    -->
    <video id="web-video-player" style="display: none;" controls></video>

    <!-- 
      Main Application UI
    -->

    <!-- Page: Loading / Initializing -->
    <div id="page-LOADING" class="page active flex flex-col justify-center items-center space-y-4">
        <div class="spinner"></div>
        <h1 class="text-2xl font-bold text-text-alt">Initializing App...</h1>
        <p id="loading-status" class="text-lg text-text-alt">Please wait.</p>
    </div>

    <!-- Page: Categories -->
    <div id="page-CATEGORIES" class="page">
        <div class="page-content p-8">
            <h1 class="text-4xl font-bold mb-8 text-primary">Categories</h1>
            <div id="category-list" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                <!-- Category items will be injected here -->
            </div>
        </div>
    </div>

    <!-- Page: Content Grid (Movies/Series) -->
    <div id="page-GRID" class="page">
        <!-- 
          We use page-content here to make the *entire page* scrollable,
          including the header. This is better for long grids.
        -->
        <div class="page-content p-8">
            <h1 id="grid-title" class="text-4xl font-bold mb-8 text-primary">Content</h1>
            <div id="content-grid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-7 gap-4">
                <!-- Grid items will be injected here -->
            </div>
        </div>
    </div>
    
    <!-- Page: Item Details (Series) -->
    <div id="page-DETAILS" class="page">
        <!-- The content here is scrollable -->
        <div id="details-content" class="page-content">
            <!-- Header section with backdrop and info -->
            <div id="details-header" class="relative h-[60vh] min-h-[400px] text-white">
                <!-- Backdrop image -->
                <div id="details-backdrop" class="absolute inset-0 w-full h-full object-cover"></div>
                <!-- Gradient overlay -->
                <div class="absolute inset-0 bg-gradient-to-t from-bg via-bg/70 to-transparent"></div>
                <!-- Content -->
                <div class="absolute bottom-0 left-0 p-8 md:p-12 z-10 flex space-x-8">
                    <img id="details-poster" src="" alt="Poster" class="w-40 md:w-52 aspect-[2/3] rounded-lg shadow-xl object-cover hidden md:block">
                    <div class="flex flex-col justify-end">
                        <h1 id="details-title" class="text-4xl md:text-6xl font-extrabold shadow-black/50" style="text-shadow: 0 2px 4px rgba(0,0,0,0.5);"></h1>
                        <p id="details-metadata" class="text-lg text-text-alt mt-2"></p>
                        <p id="details-plot" class="mt-4 text-base text-text-alt max-w-2xl line-clamp-3"></p>
                        <div class="mt-6 flex space-x-4">
                            <button id="details-play-button" class="details-button bg-primary hover:bg-primary-hover text-white px-6 py-3 rounded-md text-lg font-semibold transition-all duration-200">
                                Play
                            </button>
                            <button id="details-trailer-button" class="details-button bg-card/70 hover:bg-card text-text px-6 py-3 rounded-md text-lg font-semibold transition-all duration-200">
                                Trailer
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Seasons and Episodes Section -->
            <div class="p-8 md:p-12">
                <!-- Season Selector -->
                <div class="mb-6">
                    <h2 class="text-2xl font-bold mb-4 text-primary">Seasons</h2>
                    <div id="season-list" class="flex flex-wrap gap-4">
                        <!-- Season items injected here -->
                    </div>
                </div>
                
                <!-- Episode List -->
                <div>
                    <h2 id="episode-list-title" class="text-2xl font-bold mb-4 text-primary">Episodes</h2>
                    <div id="episode-list" class="flex flex-col gap-4">
                        <!-- Episode items injected here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 
      Global Components
    -->

    <!-- Loading Spinner Overlay -->
    <div id="loading-spinner">
        <div class="spinner"></div>
    </div>

    <!-- Error Message Popup -->
    <div id="error-message">
        <p>An error occurred!</p>
    </div>


    <script>
        /*
        =======================================================================
        Tizen IPTV Player - Main Application Logic
        =======================================================================
        */

        // --- 1. Polyfills & Helpers -----------------------------------------

        // Tizen API Mocks (for browser testing)
        if (typeof webapis === 'undefined') {
            console.warn("Tizen 'webapis' object not found. Creating mock for browser testing.");
            window.webapis = {
                avplay: {
                    open: (url) => console.log(`[MOCK] AVPlay Open: ${url}`),
                    prepare: () => console.log("[MOCK] AVPlay Prepare"),
                    prepareAsync: (cb) => { console.log("[MOCK] AVPlay PrepareAsync"); cb(); },
                    play: () => console.log("[MOCK] AVPlay Play"),
                    stop: () => console.log("[MOCK] AVPlay Stop"),
                    pause: () => console.log("[MOCK] AVPlay Pause"),
                    seekTo: (ms) => console.log(`[MOCK] AVPlay Seek: ${ms}ms`),
                    close: () => console.log("[MOCK] AVPlay Close"),
                    getState: () => 'IDLE',
                    setListener: (listener) => console.log("[MOCK] AVPlay SetListener"),
                    setDisplayRect: (x, y, w, h) => console.log(`[MOCK] AVPlay SetDisplayRect: ${x},${y},${w},${h}`),
                    setDrm: () => console.log("[MOCK] AVPlay SetDrm"),
                },
                appcommon: {
                    setScreenSaver: (state) => console.log(`[MOCK] ScreenSaver: ${state}`),
                    AppCommonScreenSaverState: { SCREEN_SAVER_OFF: 'OFF' }
                },
                inputdevice: {
                    registerKey: (key) => console.log(`[MOCK] Register Key: ${key}`),
                    unregisterKey: (key) => console.log(`[MOCK] Unregister Key: ${key}`),
                },
                adinfo: {
                    getTIFA: () => 'mock-tifa-id',
                    isTrackingEnabled: () => true
                },
                productinfo: {
                    is8KPanel: () => false,
                    isUdPanel: () => true, // Assume 4K
                    getModel: () => 'MOCK_TIZEN_TV'
                }
            };
        }
        
        // Helper to check if running on Tizen
        const isTizen = (typeof tizen !== 'undefined') && (typeof webapis !== 'undefined');
        console.log(`Running on Tizen: ${isTizen}`);

        // DOM query selectors
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        // Key codes
        const KEY_LEFT = 37;
        const KEY_UP = 38;
        const KEY_RIGHT = 39;
        const KEY_DOWN = 40;
        const KEY_ENTER = 13;
        const KEY_OK = 13; // Often same as Enter
        const KEY_RETURN = 10009; // Tizen 'Back' key
        const KEY_BACK = 10009; // Alias
        const KEY_PLAY = 415;
        const KEY_PAUSE = 19;
        const KEY_STOP = 413;
        const KEY_FF = 417;
        const KEY_RW = 412;
        const KEY_0 = 48;
        const KEY_1 = 49;
        const KEY_2 = 50;
        const KEY_3 = 51;
        const KEY_4 = 52;
        const KEY_5 = 53;
        const KEY_6 = 54;
        const KEY_7 = 55;
        const KEY_8 = 56;
        const KEY_9 = 57;
        
        // List of keys to register on Tizen
        const TIZEN_KEYS = [
            'MediaPlay', 'MediaPause', 'MediaStop', 'MediaFastForward', 'MediaRewind',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
        ];

        // --- 2. Application State -------------------------------------------

        let currentPage = 'LOADING'; // Tracks the visible page
        let allData = []; // Holds the master list of items for the current grid
        let currentCategories = []; // Holds the list of categories
        let currentItem = null; // The movie/series item currently being viewed/played
        let currentEpisode = null; // The specific episode being played
        let currentCategoryLink = null; // Holds {self, next, prev} links for pagination
        let tizenAvPlayer = null; // Holds the Tizen AVPlay instance
        let saveProgressInterval = null; // Interval timer for saving progress

        // Stores ephemeral state, like focus position
        const globalState = {
            lastFocusedId: null,      // e.g., 'grid-item-1234'
            lastFocusedIndex: 0,    // e.g., 5
            focusAfterLoad: null,   // The index to focus after an async append
            categoryFocusId: null   // e.g., 'category-item-live'
        };
        
        // Stores persistent user settings
        let userSettings = {
            m3uUrl: '',
            watchProgress: {} // { "stream_id": { "position": 1234, "duration": 5000, "percentage": 24.68 } }
        };
        
        // --- 3. Core App Logic ----------------------------------------------

        /**
         * Called when the application starts.
         */
        function onAppLoad() {
            console.log("Application loading...");
            showLoading(true, "Initializing...");

            // 1. Load settings
            loadUserSettings();
            
            // 2. Register Tizen keys
            registerTizenKeys();
            
            // 3. Add global key listener
            document.addEventListener('keydown', handleKey);
            
            // 4. Set screen saver off
            if (isTizen) {
                try {
                    webapis.appcommon.setScreenSaver(webapis.appcommon.AppCommonScreenSaverState.SCREEN_SAVER_OFF);
                    console.log("Screen saver disabled.");
                } catch (e) {
                    console.error("Error disabling screen saver:", e);
                }
            }

            // 5. Fetch initial data
            // TODO: Replace with real login/config
            if (!userSettings.m3uUrl) {
                userSettings.m3uUrl = "http://example.com/api/v1"; // Hardcoded for now
            }
            
            // Start by fetching categories
            fetchCategories();
        }

        /**
         * Fetches the main category list.
         */
        function fetchCategories() {
            // TODO: Use real API URL
            const categoriesUrl = 'https://api.npoint.io/4e4f7e5f6e8c7b8c7c1f'; // Mock API
            
            showLoading(true, "Loading categories...");
            
            fetch(categoriesUrl)
            .then(response => response.json())
            .then(data => {
                currentCategories = data.categories; // Assuming API structure
                renderCategories(currentCategories);
                showPage('CATEGORIES');
                showLoading(false);
            })
            .catch(error => {
                console.error("Error fetching categories:", error);
                showError("Failed to load categories.");
            });
        }
        
        /**
         * Fetches content for a specific category URL (movies, series, etc.)
         * @param {string} url - The API endpoint to fetch.
         * @param {boolean} append - If true, appends new items to `allData` instead of replacing.
         */
        function fetchContent(url, append = false) {
            if (!url) {
                console.error("fetchContent called with null or undefined URL.");
                showError("Invalid content URL.");
                showLoading(false);
                return;
            }
            
            // Don't show loading overlay for appended content, it's smoother without
            if (!append) {
                showLoading(true);
            }

            console.log(`Fetching content from: ${url}`);
            
            fetch(url)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Content data received:", data);
                
                // --- Navigation Links (Pagination) ---
                const links = data.links || (data.pagination ? data.pagination.links : null);
                if (links) {
                    currentCategoryLink = {
                        self: links.self,
                        next: links.next,
                        prev: links.prev
                    };
                    console.log("Updated category links:", currentCategoryLink);
                } else {
                    console.log("No pagination links found in response.");
                    // Don't nullify if appending, we might be at the end
                    if (!append) {
                        currentCategoryLink = null;
                    } else if (currentCategoryLink) {
                        // We've appended, and there's no 'next' link, so we are at the end.
                        currentCategoryLink.next = null;
                    }
                }
                
                // --- Content Items ---
                const newItems = data.items || data.data || []; // Adjust based on API structure
                
                if (append) {
                    console.log(`Appending ${newItems.length} new items.`);
                    allData.push(...newItems);
                    appendContentGrid(newItems); // Call the new append function
                    
                    // Restore focus to the item we were trying to navigate TO
                    const targetIndex = globalState.focusAfterLoad;
                    if (targetIndex != null) {
                        const items = $$('#content-grid .grid-item');
                        const targetItem = items[targetIndex];
                        if (targetItem) {
                            console.log(`Restoring focus to appended item index: ${targetIndex}`);
                            targetItem.focus();
                            targetItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        } else {
                            console.warn(`Could not find item at index ${targetIndex} after append.`);
                            // Fallback: focus the last item from the *previous* batch
                            const fallbackItem = items[globalState.lastFocusedIndex];
                            if (fallbackItem) {
                                fallbackItem.focus();
                            }
                        }
                        globalState.focusAfterLoad = null; // Clear the flag
                    }
                    
                } else {
                    console.log(`Rendering ${newItems.length} items (full render).`);
                    allData = newItems;
                    renderContentGrid(allData, true); // Call the modified full-render function
                }

                // Hide loading spinner (if it was shown)
                showLoading(false);
            })
            .catch(error => {
                console.error("Error fetching content:", error);
                showLoading(false);
                showError(`Failed to load content: ${error.message}`);
                // If we fail, go back to categories to not be stuck
                if (!append) {
                    showPage('CATEGORIES');
                }
            });
        }

        /**
         * Fetches the detailed information for a series.
         * @param {object} item - The series item (must have `series_id`).
         */
        function fetchSeriesDetails(item) {
            // TODO: Use real API URL
            const detailsUrl = `https://api.npoint.io/0e5b7b8a7c2c3b5a7d0d?id=${item.series_id}`; // Mock API
            
            showLoading(true, "Loading details...");
            
            fetch(detailsUrl)
            .then(response => response.json())
            .then(data => {
                currentItem = data; // Store the full details
                renderDetailsPage(data);
                showPage('DETAILS');
                showLoading(false);
            })
            .catch(error => {
                console.error("Error fetching series details:", error);
                showError("Failed to load series details.");
                showLoading(false);
            });
        }


        // --- 4. Page Rendering ----------------------------------------------

        /**
         * Switches the visible page.
         * @param {string} pageId - The ID of the page to show (e.g., 'CATEGORIES', 'GRID').
         */
        function showPage(pageId) {
            console.log(`Showing page: ${pageId}`);
            // Find all pages and hide them
            $$('.page').forEach(page => {
                page.classList.remove('active');
            });
            
            // Show the target page
            const targetPage = $(`#page-${pageId}`);
            if (targetPage) {
                targetPage.classList.add('active');
                currentPage = pageId;
                
                // Automatically focus the first item or restore focus
                if (pageId === 'CATEGORIES') {
                    let itemToFocus = null;
                    if (globalState.categoryFocusId) {
                        itemToFocus = $(`#${globalState.categoryFocusId}`);
                    }
                    if (!itemToFocus) {
                        itemToFocus = $('#category-list .category-item');
                    }
                    if (itemToFocus) {
                        itemToFocus.focus();
                        itemToFocus.scrollIntoView({ behavior: 'auto', block: 'center' });
                    }
                } else if (pageId === 'GRID') {
                    // Focus is handled by renderContentGrid(..., true)
                } else if (pageId === 'DETAILS') {
                    // Focus the 'Play' button by default
                    const playButton = $('#details-play-button');
                    if (playButton) {
                        playButton.focus();
                    }
                }
                
            } else {
                console.error(`Page with ID 'page-${pageId}' not found!`);
            }
        }

        /**
         * Renders the category list.
         * @param {Array} categories - An array of category objects.
         */
        function renderCategories(categories) {
            const list = $('#category-list');
            list.innerHTML = ''; // Clear existing
            
            categories.forEach(category => {
                const item = document.createElement('div');
                item.className = 'category-item bg-card hover:bg-card/80 p-6 rounded-lg shadow-md cursor-pointer transition-all duration-300 transform-gpu focus:scale-105 focus:shadow-lg focus:outline-none focus:ring-4 focus:ring-primary';
                item.textContent = category.name;
                item.tabIndex = 0; // Make it focusable
                item.id = `category-item-${category.id}`;
                
                item.addEventListener('click', () => {
                    onCategorySelect(category);
                });
                
                list.appendChild(item);
            });
        }

        /**
         * Creates a single grid card element.
         * @param {object} item - The movie/series item data.
         * @param {number} index - The global index of this item in `allData`.
         * @returns {HTMLElement} The card element.
         */
        function createGridCard(item, index) {
            const card = document.createElement('div');
            card.className = 'grid-item relative aspect-[2/3] bg-card rounded-md overflow-hidden transition-all duration-300 transform-gpu focus:scale-105 focus:shadow-lg focus:outline-none focus:ring-4 focus:ring-primary focus:z-10';
            card.tabIndex = 0;
            
            // Store item data on the element for later retrieval
            card.itemData = item; 
            
            // Unique ID for focus management
            card.id = `grid-item-${item.stream_id || item.series_id || index}`;

            let title = item.name || 'Unknown Title';
            let poster = item.cover || item.poster || item.movie_image || item.stream_icon;

            // Handle series data structure (if different)
            if (item.series_id && item.info) {
                poster = item.info.cover || item.info.movie_image || poster;
                title = item.name;
            }
            
            // Add poster image
            const img = document.createElement('img');
            img.className = 'w-full h-full object-cover';
            img.src = poster || 'https://placehold.co/200x300/1F2937/FFFFFF?text=No+Poster';
            img.alt = title;
            img.loading = 'lazy'; // Use lazy loading for performance
            img.onerror = (e) => { 
                e.target.src = 'https://placehold.co/200x300/1F2937/FFFFFF?text=No+Poster';
            };
            card.appendChild(img);

            // Add title overlay
            const titleOverlay = document.createElement('div');
            titleOverlay.className = 'absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent';
            titleOverlay.innerHTML = `<h3 class="text-text text-sm font-semibold truncate">${title}</h3>`;
            card.appendChild(titleOverlay);
            
            // Add progress bar if watch progress > 0
            const progressData = userSettings.watchProgress[item.stream_id];
            if (progressData) {
                if (progressData.percentage > 5 && progressData.percentage < 95) { // Only show if partially watched
                    const progressElement = document.createElement('div');
                    progressElement.className = 'absolute bottom-0 left-0 h-1 bg-primary';
                    progressElement.style.width = `${progressData.percentage}%`;
                    card.appendChild(progressElement);
                }
            }

            // Add 'click' (Enter) listener
            card.addEventListener('click', () => {
                // When clicked, update the global state
                globalState.lastFocusedId = card.id;
                globalState.lastFocusedIndex = index; // 'index' is the globalIndex
                onGridItemSelect(item);
            });
            
            return card;
        }

        /**
         * Renders the content grid for movies/series.
         * @param {Array} items - An array of item objects.
         * @param {boolean} forceFocus - Whether to force focus on the first/last item.
         */
        function renderContentGrid(items, forceFocus = false) {
            console.log("Rendering content grid (full render)...");
            const grid = $('#content-grid');
            grid.innerHTML = ''; // Clear the grid for a full render
            
            items.forEach((item, index) => {
                const card = createGridCard(item, index);
                grid.appendChild(card);
            });
            
            if (forceFocus) {
                // Try to restore focus to the last selected item
                let itemToFocus = null;
                if (globalState.lastFocusedId) {
                    itemToFocus = $(`#${globalState.lastFocusedId}`);
                }
                
                // If not found, or no last focused, focus the first item
                if (!itemToFocus) {
                    itemToFocus = grid.querySelector('.grid-item');
                }
                
                if (itemToFocus) {
                    itemToFocus.focus();
                    itemToFocus.scrollIntoView({ behavior: 'auto', block: 'center' });
                }
            }
        }
        
        /**
         * Appends new items to the content grid without refreshing.
         * @param {Array} newItems - An array of new item objects to append.
         */
        function appendContentGrid(newItems) {
            console.log("Appending new items to grid...");
            const grid = $('#content-grid');
            const existingItemCount = grid.children.length;
            
            newItems.forEach((item, index) => {
                // The index needs to be global, not relative to newItems
                const globalIndex = existingItemCount + index;
                const card = createGridCard(item, globalIndex);
                grid.appendChild(card);
            });
        }

        /**
         * Renders the details page for a series.
         * @param {object} seriesData - The full data object for the series.
         */
        function renderDetailsPage(seriesData) {
            // Header
            $('#details-backdrop').style.backgroundImage = `url(${seriesData.info.backdrop_path || ''})`;
            $('#details-poster').src = seriesData.info.cover || 'https://placehold.co/200x300/1F2937/FFFFFF?text=No+Poster';
            $('#details-title').textContent = seriesData.info.name || 'Unknown Series';
            $('#details-metadata').textContent = `${seriesData.info.releaseDate || ''} â€¢ ${seriesData.info.genre || ''}`;
            $('#details-plot').textContent = seriesData.info.plot || 'No description available.';

            // Season List
            const seasonList = $('#season-list');
            seasonList.innerHTML = '';
            if (seriesData.seasons && seriesData.seasons.length > 0) {
                seriesData.seasons.forEach((season) => {
                    const item = document.createElement('button');
                    item.className = 'season-item bg-card hover:bg-card/80 px-5 py-3 rounded-md text-text-alt font-semibold transition-all duration-300 transform-gpu focus:scale-105 focus:shadow-lg focus:outline-none focus:ring-4 focus:ring-primary';
                    item.textContent = `Season ${season.season_number}`;
                    item.tabIndex = 0;
                    item.dataset.seasonNumber = season.season_number;
                    
                    item.addEventListener('click', () => {
                        renderEpisodeList(seriesData.episodes[season.season_number]);
                        // Update focus style
                        $$('.season-item').forEach(btn => btn.classList.remove('bg-primary', 'text-white'));
                        item.classList.add('bg-primary', 'text-white');
                    });
                    
                    seasonList.appendChild(item);
                });
            } else {
                seasonList.innerHTML = '<p class="text-text-alt">No season information available.</p>';
            }
            
            // Episode List (render first season by default)
            const firstSeasonNum = seriesData.seasons.length > 0 ? seriesData.seasons[0].season_number : 1;
            renderEpisodeList(seriesData.episodes[firstSeasonNum]);
            // Highlight first season
            const firstSeasonBtn = $(`#season-list .season-item[data-season-number='${firstSeasonNum}']`);
            if(firstSeasonBtn) {
                firstSeasonBtn.classList.add('bg-primary', 'text-white');
            }
        }
        
        /**
         * Renders the list of episodes for a given season.
         * @param {Array} episodes - An array of episode objects.
         */
        function renderEpisodeList(episodes) {
            const list = $('#episode-list');
            list.innerHTML = '';
            
            if (!episodes || episodes.length === 0) {
                list.innerHTML = '<p class="text-text-alt">No episodes found for this season.</p>';
                return;
            }
            
            episodes.forEach((ep) => {
                const item = document.createElement('div');
                item.className = 'episode-item bg-card hover:bg-card/80 p-4 rounded-lg shadow-sm flex items-center space-x-4 cursor-pointer transition-all duration-300 transform-gpu focus:scale-105 focus:shadow-lg focus:outline-none focus:ring-4 focus:ring-primary';
                item.tabIndex = 0;
                
                // Poster
                const img = document.createElement('img');
                img.src = ep.info.movie_image || 'https://placehold.co/150x84/1F2937/FFFFFF?text=No+Image';
                img.alt = ep.title;
                img.className = 'w-36 h-20 object-cover rounded-md bg-bg-alt';
                
                // Info
                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex-1';
                infoDiv.innerHTML = `
                    <h4 class="text-lg font-semibold text-text">${ep.episode_num}. ${ep.title}</h4>
                    <p class="text-sm text-text-alt line-clamp-2 mt-1">${ep.info.plot || 'No description'}</p>
                `;
                
                item.appendChild(img);
                item.appendChild(infoDiv);
                
                item.addEventListener('click', () => {
                    onEpisodeSelect(ep);
                });
                
                list.appendChild(item);
            });
        }


        // --- 5. Event Handlers & Navigation ---------------------------------

        /**
         * Handles all keydown events for the app.
         * @param {KeyboardEvent} e - The keydown event.
         */
        function handleKey(e) {
            console.log(`Key pressed: ${e.keyCode} on page: ${currentPage}`);
            
            // Global 'Back' key handling
            if (e.keyCode === KEY_BACK || e.keyCode === KEY_RETURN) {
                if (currentPage === 'GRID') {
                    e.preventDefault();
                    globalState.lastFocusedId = null; // Clear last focused item
                    showPage('CATEGORIES');
                    return;
                }
                if (currentPage === 'DETAILS') {
                    e.preventDefault();
                    // Go back to grid, focus should be restored
                    showPage('GRID'); 
                    return;
                }
                if (currentPage === 'CATEGORIES') {
                    e.preventDefault();
                    // Exit app?
                    console.log("At top level. Exit app?");
                    // tizen.application.getCurrentApplication().exit();
                    return;
                }
            }

            // Page-specific key handling
            switch (currentPage) {
                case 'CATEGORIES':
                    handleCategoryKey(e);
                    break;
                case 'GRID':
                    handleGridKey(e);
                    break;
                case 'DETAILS':
                    handleDetailsKey(e);
                    break;
            }
        }
        
        /**
         * Handles navigation within the 'CATEGORIES' page.
         */
        function handleCategoryKey(e) {
            const focused = document.activeElement;
            if (!focused || !focused.classList.contains('category-item')) {
                const firstItem = $('#category-list .category-item');
                if (firstItem) firstItem.focus();
                return;
            }

            const items = Array.from($$('#category-list .category-item'));
            const currentIndex = items.indexOf(focused);
            if (currentIndex === -1) return;
            
            // Simple grid navigation
            // TODO: Make this smarter with dynamic row calculation
            const itemsPerRow = 4; // Assume 4 for now
            let nextIndex = -1;

            switch (e.keyCode) {
                case KEY_UP:
                    nextIndex = currentIndex - itemsPerRow;
                    break;
                case KEY_DOWN:
                    nextIndex = currentIndex + itemsPerRow;
                    break;
                case KEY_LEFT:
                    nextIndex = currentIndex - 1;
                    if (currentIndex % itemsPerRow === 0) nextIndex = -1; // Stop at left edge
                    break;
                case KEY_RIGHT:
                    nextIndex = currentIndex + 1;
                    if ((currentIndex + 1) % itemsPerRow === 0) nextIndex = -1; // Stop at right edge
                    break;
                case KEY_ENTER:
                case KEY_OK:
                    onCategorySelect(currentCategories[currentIndex]); // Assuming order matches
                    return;
            }

            if (nextIndex >= 0 && nextIndex < items.length) {
                const nextItem = items[nextIndex];
                if (nextItem) {
                    nextItem.focus();
                    nextItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }
        
        /**
         * Handles navigation within the 'GRID' page.
         */
        function handleGridKey(e) {
            const focused = document.activeElement;
            if (!focused || !focused.classList.contains('grid-item')) {
                const firstItem = $('#content-grid .grid-item');
                if (firstItem) {
                    firstItem.focus();
                    firstItem.scrollIntoView({ behavior: 'auto', block: 'center' });
                }
                return;
            }

            const items = Array.from($$('#content-grid .grid-item'));
            const currentIndex = items.indexOf(focused);
            if (currentIndex === -1) {
                console.warn("Focused item not in grid item list!");
                return;
            }
            
            // Store current index in global state in case of selection
            globalState.lastFocusedIndex = currentIndex;
            globalState.lastFocusedId = focused.id; // Also store ID

            const itemsPerRow = calculateItemsPerRow();
            let nextIndex = -1;

            switch (e.keyCode) {
                case KEY_UP:
                    nextIndex = currentIndex - itemsPerRow;
                    break;
                case KEY_DOWN:
                    nextIndex = currentIndex + itemsPerRow;
                    break;
                case KEY_LEFT:
                    nextIndex = currentIndex - 1;
                    if (currentIndex % itemsPerRow === 0) nextIndex = -1; // Stop at left edge
                    break;
                case KEY_RIGHT:
                    nextIndex = currentIndex + 1;
                    if ((currentIndex + 1) % itemsPerRow === 0) nextIndex = -1; // Stop at right edge
                    break;
                case KEY_ENTER:
                case KEY_OK:
                    onGridItemSelect(focused.itemData);
                    return; // Don't navigate
                // Back/Return is handled globally
            }

            if (nextIndex >= 0 && nextIndex < items.length) {
                const nextItem = items[nextIndex];
                if (nextItem) {
                    nextItem.focus();
                    // Use 'nearest' to avoid unnecessary scrolling if half-visible
                    nextItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            } else if (e.keyCode === KEY_DOWN) {
                // Reached the bottom, try to load more
                console.log("Grid nav: Reached bottom, checking for next page.");
                if (currentCategoryLink && currentCategoryLink.next) {
                    showLoading(true); // Show loading since it's a key action
                    console.log("Grid nav: Fetching next page:", currentCategoryLink.next);
                    
                    // **** NEW: Store the index we want to focus after load ****
                    // We were at 'currentIndex', we want to go to 'currentIndex + itemsPerRow'
                    globalState.focusAfterLoad = currentIndex + itemsPerRow;
                    
                    fetchContent(currentCategoryLink.next, true); // 'true' for append
                }
            }
        }
        
        /**
         * Handles navigation within the 'DETAILS' page.
         */
        function handleDetailsKey(e) {
            // TODO: Implement spatial navigation for details page
            // This is complex because the layout isn't a simple grid.
            // You need to manually define 'up', 'down', 'left', 'right' for each element.
            console.log("Details page navigation not fully implemented.");
        }

        /**
        * Called when a category is selected.
        * @param {object} category - The selected category object.
        */
        function onCategorySelect(category) {
            console.log("Category selected:", category);
            globalState.categoryFocusId = `category-item-${category.id}`; // Save focus
            $('#grid-title').textContent = category.name;
            fetchContent(category.url, false); // false = full refresh
            showPage('GRID');
        }
        
        /**
         * Called when a grid item (movie/series) is selected.
         * @param {object} item - The selected item object.
         */
        function onGridItemSelect(item) {
            console.log("Grid item selected:", item);
            currentItem = item; // Store as the "current" item
            
            if (item.stream_type === 'movie' || !item.series_id) {
                // It's a movie, play it directly
                currentEpisode = null; // Ensure no episode is set
                playItem(item);
            } else {
                // It's a series, fetch details
                fetchSeriesDetails(item);
            }
        }
        
        /**
         * Called when an episode is selected from the details page.
         * @param {object} episode - The selected episode object.
         */
        function onEpisodeSelect(episode) {
            console.log("Episode selected:", episode);
            currentEpisode = episode; // Store the specific episode
            // `currentItem` should already be the series
            playItem(currentItem, episode);
        }
        
        /**
         * Calculates how many items are in a single row of the content grid.
         * @returns {number} The number of items per row.
         */
        function calculateItemsPerRow() {
            const grid = $('#content-grid');
            if (!grid) return 5; // Default fallback
            
            const gridStyle = window.getComputedStyle(grid);
            const gridCols = gridStyle.getPropertyValue('grid-template-columns');
            // This will return something like "repeat(7, minmax(0, 1fr))"
            const match = gridCols.match(/repeat\((\d+)/);
            
            if (match && match[1]) {
                return parseInt(match[1], 10);
            }
            
            // Fallback for different Tailwind responsive sizes
            const screenWidth = window.innerWidth;
            if (screenWidth >= 1280) return 7; // xl
            if (screenWidth >= 1024) return 6; // lg
            if (screenWidth >= 768) return 5; // md
            if (screenWidth >= 640) return 4; // sm
            return 3; // default
        }


        // --- 6. Media Player Logic ------------------------------------------
        
        /**
         * Main function to play a video.
         * @param {object} item - The movie or series item.
         * @param {object} [episode] - The specific episode (if series).
         */
        function playItem(item, episode = null) {
            let streamUrl, streamId;
            
            if (episode) {
                // Playing an episode
                streamUrl = `${userSettings.m3uUrl}/series/${item.series_id}/${episode.stream_id}.m3u8`; // Example URL
                streamId = episode.stream_id;
            } else {
                // Playing a movie
                streamUrl = `${userSettings.m3uUrl}/movie/${item.stream_id}.m3u8`; // Example URL
                streamId = item.stream_id;
            }
            
            console.log(`Playing stream: ${streamUrl} (ID: ${streamId})`);
            
            // Stop any existing player
            stopPlayer();
            
            // Get saved progress
            const savedProgress = userSettings.watchProgress[streamId];
            const startTime = savedProgress ? savedProgress.position : 0;
            
            if (isTizen) {
                playTizen(streamUrl, startTime);
            } else {
                playWeb(streamUrl, startTime);
            }
            
            // Start periodic progress saving
            clearInterval(saveProgressInterval);
            saveProgressInterval = setInterval(saveCurrentProgress, 5000); // Save every 5 seconds
        }
        
        /**
         * Saves the current playback progress to userSettings.
         */
        function saveCurrentProgress() {
            let position, duration, streamId;
            
            if (isTizen && tizenAvPlayer) {
                try {
                    position = tizenAvPlayer.getCurrentTime();
                    duration = tizenAvPlayer.getDuration();
                } catch (e) {
                    console.warn("Failed to get Tizen player time:", e);
                    return;
                }
            } else {
                const player = $('#web-video-player');
                if (player && !player.paused) {
                    position = Math.floor(player.currentTime * 1000); // to ms
                    duration = Math.floor(player.duration * 1000); // to ms
                } else {
                    return; // Don't save if not playing
                }
            }
            
            if (currentEpisode) {
                streamId = currentEpisode.stream_id;
            } else if (currentItem) {
                streamId = currentItem.stream_id;
            } else {
                return; // No item context
            }
            
            if (!streamId || !duration || duration <= 0 || !position) {
                return; // Invalid data
            }
            
            const percentage = (position / duration) * 100;
            
            userSettings.watchProgress[streamId] = {
                position: position,
                duration: duration,
                percentage: percentage
            };
            
            // console.log(`Progress saved for ${streamId}: ${position}ms / ${duration}ms (${percentage.toFixed(2)}%)`);
        }

        /**
         * Plays a stream using the HTML5 <video> tag (browser).
         * @param {string} url - The URL of the stream.
         * @param {number} startTime - The time to seek to (in ms).
         */
        function playWeb(url, startTime) {
            console.log(`Playing with Web Player (start: ${startTime}ms)`);
            const player = $('#web-video-player');
            player.style.display = 'block';
            player.src = url;
            
            player.onloadedmetadata = () => {
                if (startTime > 0) {
                    player.currentTime = startTime / 1000; // convert to seconds
                }
                player.play();
            };
            
            player.ontimeupdate = saveCurrentProgress; // Save progress on update
            
            player.onended = () => {
                console.log("Web player finished.");
                stopPlayer();
                goBack(); // Go back to previous screen
            };
            
            player.onerror = (e) => {
                console.error("Web player error:", e);
                showError("Video playback failed.");
                stopPlayer();
                goBack();
            };
        }
        
        /**
         * Plays a stream using the Tizen AVPlay API.
         * @param {string} url - The URL of the stream.
         * @param {number} startTime - The time to seek to (in ms).
         */
        function playTizen(url, startTime) {
            console.log(`Playing with Tizen Player (start: ${startTime}ms)`);
            try {
                tizenAvPlayer = webapis.avplay;
                
                const playerRect = {
                    x: 0,
                    y: 0,
                    w: window.innerWidth,
                    h: window.innerHeight
                };
                
                const listener = {
                    onbufferingstart: () => console.log("AVPlay: Buffering start..."),
                    onbufferingprogress: (percent) => console.log(`AVPlay: Buffering... ${percent}%`),
                    onbufferingcomplete: () => {
                        console.log("AVPlay: Buffering complete.");
                        tizenAvPlayer.play();
                        if (startTime > 0) {
                            console.log(`AVPlay: Seeking to ${startTime}ms`);
                            tizenAvPlayer.seekTo(startTime);
                        }
                    },
                    onstreamcompleted: () => {
                        console.log("AVPlay: Stream completed.");
                        stopPlayer();
                        goBack();
                    },
                    oncurrentplaytime: (time) => {
                        // We use a separate interval for saving, but this is good for debug
                        // console.log(`AVPlay: Playback time: ${time}ms`);
                    },
                    onerror: (e) => {
                        console.error("AVPlay Error:", e);
                        showError(`Playback Error: ${e}`);
                        stopPlayer();
                        goBack();
                    },
                    onevent: (type, data) => {
                        console.log(`AVPlay Event: ${type}`, data);
                    }
                };

                tizenAvPlayer.open(url);
                tizenAvPlayer.setListener(listener);
                tizenAvPlayer.setDisplayRect(playerRect.x, playerRect.y, playerRect.w, playerRect.h);
                
                // Show the black overlay to capture keys
                $('#tizen-player-overlay').style.display = 'block';
                
                // TODO: Add DRM logic here if needed
                // tizenAvPlayer.setDrm(...)
                
                tizenAvPlayer.prepareAsync(() => {
                    console.log("AVPlay: Prepare successful.");
                }, (e) => {
                    console.error("AVPlay: Prepare failed.", e);
                    showError("Failed to prepare video.");
                });
                
            } catch (e) {
                console.error("Tizen AVPlay critical error:", e);
                showError("Tizen AVPlay API failed.");
                goBack();
            }
        }

        /**
         * Stops the currently active player (Tizen or Web)
         */
        function stopPlayer() {
            clearInterval(saveProgressInterval); // Stop periodic saving
            saveCurrentProgress(); // Do one final save
            saveUserSettings(); // Persist to storage
            
            currentItem = null;
            currentEpisode = null;
            
            if (isTizen && tizenAvPlayer) {
                try {
                    console.log("Stopping Tizen Player");
                    if (tizenAvPlayer.getState() !== 'IDLE') {
                        tizenAvPlayer.stop();
                    }
                    tizenAvPlayer.close();
                    tizenAvPlayer = null;
                    $('#tizen-player-overlay').style.display = 'none';
                } catch (e) {
                    console.error("Error stopping Tizen player:", e);
                }
            } else {
                console.log("Stopping Web Player");
                const player = $('#web-video-player');
                player.pause();
                player.src = '';
                player.style.display = 'none';
                player.ontimeupdate = null; // Clear listener
                player.onloadedmetadata = null;
                // Clear subtitle tracks
                const oldTracks = player.querySelectorAll('track');
                oldTracks.forEach(t => t.remove());
            }
        }


        // --- 7. Utility & Helper Functions ----------------------------------
        
        /**
         * Returns to the previous logical page (e.g., from Player to Details/Grid).
         */
        function goBack() {
            // This function is called after video stops.
            // We don't want to change pages, just ensure player is hidden.
            // The 'Back' key handler is responsible for page changes.
            console.log("goBack() called, player should be hidden.");
        }

        /**
         * Shows or hides the global loading spinner.
         * @param {boolean} show - True to show, false to hide.
         * @param {string} [text] - Optional text to display.
         */
        function showLoading(show, text = "") {
            const spinner = $('#loading-spinner');
            const status = $('#loading-status');
            
            if (show) {
                if (status && currentPage === 'LOADING') {
                    status.textContent = text || "Loading...";
                }
                if (spinner) spinner.style.display = 'flex';
            } else {
                if (spinner) spinner.style.display = 'none';
            }
        }
        
        let errorTimer = null;
        /**
         * Shows a temporary error message at the bottom of the screen.
         * @param {string} message - The error message to display.
         */
        function showError(message) {
            const errorEl = $('#error-message');
            if (!errorEl) return;
            
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            
            // Force reflow to enable transition
            void errorEl.offsetWidth; 
            errorEl.style.opacity = '1';

            // Clear existing timer
            if (errorTimer) {
                clearTimeout(errorTimer);
            }
            
            // Hide after 3 seconds
            errorTimer = setTimeout(() => {
                errorEl.style.opacity = '0';
                setTimeout(() => {
                    errorEl.style.display = 'none';
                }, 300); // Wait for fade out
            }, 3000);
        }

        /**
         * Loads user settings from Tizen storage or localStorage.
         */
        function loadUserSettings() {
            try {
                const storedSettings = localStorage.getItem('tizenIptvSettings');
                if (storedSettings) {
                    userSettings = JSON.parse(storedSettings);
                    console.log("User settings loaded:", userSettings);
                } else {
                    console.log("No user settings found, using defaults.");
                }
            } catch (e) {
                console.error("Failed to load user settings:", e);
            }
        }
        
        /**
         * Saves user settings to Tizen storage or localStorage.
         */
        function saveUserSettings() {
            try {
                localStorage.setItem('tizenIptvSettings', JSON.stringify(userSettings));
                // console.log("User settings saved.");
            } catch (e) {
                console.error("Failed to save user settings:", e);
            }
        }

        /**
         * Registers Tizen-specific keys for the application.
         */
        function registerTizenKeys() {
            if (!isTizen) return;
            
            try {
                TIZEN_KEYS.forEach(key => {
                    webapis.inputdevice.registerKey(key);
                    console.log(`Registered key: ${key}`);
                });
            } catch (e) {
                console.error("Error registering Tizen keys:", e);
            }
        }

        // --- 8. App Initialization ------------------------------------------

        // Start the application when the window is loaded
        window.onload = onAppLoad;

    </script>
</body>
</html>